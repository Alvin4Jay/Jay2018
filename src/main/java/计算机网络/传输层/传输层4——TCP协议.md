# 面向连接的TCP协议 #

## 一、TCP连接概述

###1.TCP连接

- 面向连接: 
  - 两个进程在进行数据交换前，必须先进行**三次握手**(交换控制信息)，初始化发送方与接收方的状态变量。
  - 连接状态保留在端系统中，不为路由器所知，路由器不维护TCP连接状态。 
    - 全双工服务
    - 同一连接上的双向数据流
- 点到点:
  一个发送方和一个接收方之间的连接
- 三次握手：客户端首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段进行响应，最后客户端再用第三个特殊报文段作为响应。前两个报文段不承载有效载荷，即不包含应用数据；第三个报文段可承载有效载荷。
- 流量控制:
    - 发送方发送速率不能超过接收方能力
- 拥塞控制:
    - 网络拥塞时遏制发送方速率

![](http://onh97xzo0.bkt.clouddn.com/3-5.PNG)

​													图1 TCP 发送缓存和接收缓存

​	如图1所示，一旦建立TCP连接，两个应用进程就可以交换数据了。在客户端向服务端发送数据时，客户进程通过套接字传递应用数据到运输层。运输层TCP将这些数据引导到连接的发送缓存中，发送缓存是三次握手初期设置的缓存之一。TCP从缓存中取出并放入报文段中，并送入网络。TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度(MSS)，MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度(最大传输单元MTU)来设置。**MSS指报文段中应用层数据的最大长度，不是指包括TCP首部在内的TCP报文段的最大长度。**

​	TCP为每块客户数据配上一个TCP首部，形成多个TCP报文段。这些报文段被下发至网络层，网络层将其分别封装在网络层IP数据报中，并发送至网络。当TCP在另一端接收到一个报文段时，该报文段中的数据被放入TCP连接的接收缓存中，应用程序从此缓存中读取数据流。TCP连接的每一端都有各自的发送和接收缓存。

​	可见，TCP连接包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。在这两台主机之间的网络元素(路由器、交换机和中继器)中，无该连接的任何缓存和变量。

##二、TCP报文段结构

![](http://onh97xzo0.bkt.clouddn.com/3-6.PNG)

​												  图2 TCP报文段结构  

TCP报文段由首部字段和数据字段组成，数据字段含有一块应用数据。MSS限制了报文段数据字段的最大长度。

- 首部的源端口号和目的端口号用于多路复用和多路分解来自或送到上层应用的数据。
- 32比特的序号和确认号用于实现可靠数据传输服务。
- 16比特的接收窗口字段用于流量控制，表示接收方愿意接受的字节数量。
- 检验和字段。
- 4比特的首部长度字段。指示了**以32比特的字为单位**的TCP首部长度。
- 标志字段，如ACK、SYN、FIN、RST等。

###1.TCP序号和确认号

​	TCP把数据看成一个无结构、有序的字节流。序号建立在传送的字节流之上，而不是传送的报文段。

####(1) 序号Seq:

	报文段中第1个数据字节在字节流中的位置编号

####(2) 确认号ACK

	期望从对方收到下一个字节的序号(累计确认)

###2. Telnet: 序号和确认号的一个学习案例

![](http://onh97xzo0.bkt.clouddn.com/3-7.PNG)

​									图3 一个经TCP的简单Telnet应用的确认号和序号

​	Telnet协议是一个用于远程登录的流行应用层协议，该链接中的数据是没有加密的。在客户端的用户键入的每一个字符都会被发送至远程主机；远程主机将回送每个字符的副本给客户，并将这些字符显示在Telnet客户的屏幕上。这种“回显”用于确保由Telnet用户发送的字符被远程主机所接收并在远程站点得到了处理。因此，从用户键入字符到字符被显示在用户屏幕上这段时间，每个字符在网络中传输了两次。

 	UDP与TCP各自适用的协议

​		(1)TCP: FTP HTTP SMTP Telnet

​		(2)UDP: DNS

##三、 往返时间的估计与超时

​	超时时间必须大于连接的往返时间(RTT)，即一个报文段从发出到被确认的时间。

- 往返时间(EstimatedRTT)的估计
  $$
  EstimatedRTT=0.875*EstimatedRTT + 0.125*SampleRTT
  $$
  其中SampleRTT(样本RTT)为从某报文被发出到对该报文段的确认被收到之间的时间量。从公式可看出，EstimatedRTT是一个SampleRTT的加权平均值，加权平均对最近的样本赋予的权值大于对老样本赋予的权值。这是因为越近的样本越能反应网络目前的拥塞情况。

- RTT偏差DevRTT，用于估算SampleRTT一般会偏离EstimatedRTT的程度
  $$
  DevRTT= (1-0.25)*DevRTT + 0.25*|SampleRTT - EstimatedRTT|
  $$

- 设置和管理重传超时间隔TimeoutInterval
  $$
  TimeoutInteval = EstimatedRTT + 4 * DevRTT
  $$
  推荐的初始TimeoutInterval值为1秒。

##四、可靠数据传输

​	TCP在 IP不可靠的尽力而为服务之上创建了一种可靠数据传输服务。TCP的可靠数据传输服务确保一个进程从其接收缓存中读取的数据流是无损坏、无间隔、非冗余、按序的数据流；即该字节流与连接的另一方端系统发送的字节流是完全相同的。并且，推荐的定时器管理过程是**仅使用单一的重传定时器**。

###1. 简化的TCP发送方

​	在TCP发送方高度简化的描述中，发送方只用超时来恢复丢失的报文段。与发送方和接收方有关的3个主要事件是从上层应用接收数据；定时器超时(重传)和收到ACK。(见P164 图3-33 简化的TCP发送方)

### 2. 优化点

- **超时间隔加倍**：**在定时器时限过期后(重传)，超时间隔长度设为先前值的两倍，而不是从EstimatedRTT和DevRTT推算出。**因此，该超时间隔会在每次重传后呈指数型增长。然而，每当定时器在另外两个事件(收到上层应用的数据和收到ACK)中的任意一个启动时，TimeoutIntervel由最近的EstimatedRTT和DevRTT推算得到。
- **快速重传**：超时触发重传存在的问题是超时周期可能相对较长。当一个报文段丢失时，这种长超时周期迫使发送方延迟重传丢失的分组，增加了端到端延时。然而，**发送方通常可以在超时事件发生之前通过注意冗余ACK来较好的检测丢包的情况。**冗余ACK就是再次确认某个报文段的ACK，而发送方先前已收到对该报文段的确认。**如果发送方接收到对相同数据的3个冗余ACK，说明这个已被确认3次的报文段之后的报文已丢失**。**一旦收到3个冗余ACK，TCP就会执行快速重传**，也就是**在该报文段的定时器过期之前重传丢失的报文段**。

###3. TCP可靠数据传输是GBN协议和SR协议的混合体

## 五、TCP流量控制(滑动窗口)

​	TCP协议为它的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性。流量控制服务是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。

    滑动窗口是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，
    从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。
    
    利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。分为发送窗口、接收窗口。

###1.发送窗口

滑动窗口: 以字节为单位。(根据B给出的窗口值, A构造出自己的发送窗口)

![](http://onh97xzo0.bkt.clouddn.com/3-9.PNG)

​											图4 发送方的发送窗口

1. 根据接收方B给出的报文中的接受窗口值以及ACK值（ACK字段n表示B对之前n-1个字节的确认，同时表示希望接收到的下一个字节序号是n），发送方A确定出自己的发送窗口。
2. 对于TCP会话的发送方，任何时候在其**发送缓存**内的数据都可以分为4类，“已经发送并得到对端ACK的”，“已经发送但还未收到对端ACK的”，“未发送但对端允许发送的”，“未发送且对端不允许发送”。**“已经发送但还未收到对端ACK的”和“未发送但对端允许发送的”这两部分数据称之为发送窗口**。
3. 发送端窗口在收到ACK后前沿、后沿都向前移动。

当收到接收方新的ACK对于发送窗口中后续字节的确认时(比如ACK=36)，窗口滑动，滑动原理如下图。

![](http://pbku1z6p0.bkt.clouddn.com/network-5-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8E%9F%E7%90%86.png)

​											图 5 发送窗口前移	

###2.接收窗口

1. 对于TCP的接收方，在某一时刻在它的接收缓存内存在3种。**“已接收”，“未接收准备接收”，“未接收并未准备接收”**（由于ACK直接由TCP协议栈回复，默认无应用延迟，不存在“已接收未回复ACK”）。其中**“未接收准备接收”**称之为接收窗口。

![](http://onh97xzo0.bkt.clouddn.com/3-8.PNG)

​												图6 接收方的接收窗口

2. 接收方的滑动窗口以左，是已经被接收的数据，这部分会被应用进程在合适的时机接收，窗口前沿以右的部分是不允许接收的部分，窗口中的数据，可能包含未按序到达的部分，如果字节序不能连续按序达到，接收方就不会向发送方发送期望收到的字节序号（**接收方只发送连续收到的字节序最大序号的下一个序号值**），当接收方连续收到数据时，窗口后沿会迁移，前沿要么前移要么不动，并且**发送已经确认收到的字节序的下一个序号给发送方（期望收到的字节序序号）**，已经确认收到的部分，在被应用进程接收后，可删除。对于B接收窗口中的字节，可能有些字节还没到达，那么先存下，等待缺少数据的到达。

###3.发送缓存与接收缓存的作用

![](http://onh97xzo0.bkt.clouddn.com/3-10.PNG)

​												图7 发送缓存

![](http://onh97xzo0.bkt.clouddn.com/3-11.PNG)

​												     图8 接收缓存

- 发送缓存用来暂时存放：
	-  发送应用程序传送给发送方 TCP 准备发送的数据；
	-  TCP 已发送出但尚未收到确认的数据。
- 接收缓存用来暂时存放：
	-  按序到达的、但尚未被接收应用程序读取的数据；
	-  不按序到达的数据。 

## 六、TCP连接管理——三次握手与四次挥手

​	假设运行在一台主机上(客户)的一个进程想与另一台主机(服务器)上的一个进程建立连接。客户应用进程首先通知客户TCP，想建立一个与服务器上某个进程的TCP连接。客户中的TCP会用如下的方式与服务器TCP建立连接：

###1.三次握手

![](http://onh97xzo0.bkt.clouddn.com/3-12.PNG)

​												图9 三次握手

- 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1(SYN报文段)，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
- 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户发送允许连接的报文段，即对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN+ACK报文段，客户也要为该连接分配缓存和变量。客户主机向服务器发送另一个报文段，这最后一个报文段对服务器的允许连接的报文段进行了确认。即将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。在这个阶段报文段中可以携带用户到服务器的数据。
- 一旦完成以上三步，客户和服务器之间就可以发送和接收包括数据的报文段了。在以后的每一个报文段中，SYN比特位都为0。

###2.四次挥手

​	参与一条TCP连接的两个进程中的任意一个都可以终止连接，当连接结束后，主机中的缓存和变量将被释放。

![](http://onh97xzo0.bkt.clouddn.com/3-13.PNG)

​												图10 四次挥手

- 第一次分手：主机1（可以是客户端，也可以是服务端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
- 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
- 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
- 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

###3.TCP状态

​	假设客户开始连接拆除。

![](http://onh97xzo0.bkt.clouddn.com/3-14.PNG)

​									  图11 客户TCP经历的典型TCP状态序列

![](http://onh97xzo0.bkt.clouddn.com/3-15.PNG)

​										图12 服务端TCP经历的典型的TCP状态序列

###4.问题

####(1)为什么time_wait需要等待2MSL(最长报文段寿命)

- 为了保证 A 发送的最后一个 ACK 报文段能够到达B。防止B无法进入CLOSED状态。
- 防止 “已失效的连接请求报文段”出现在本连接中。使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

####(2)为什么需要三次握手，而不是二次、四次？

三次握手能够保证A B之间的可靠传输

1. 四次握手(多了):

	三次握手中B发给A的报文段可以拆为两份报文段，可以先发送一个确认报文段(ACK=1,ack=x+1)，然后再发送一个同步报文段(SYN=1, seq=y),但是效果跟三次握手是一样的，多了一次报文段传输。三次可以提高连接的速度与效率。

2. 二次握手(不够)

	- A 发送同步信号SYN + A's Initial sequence number
	- B发送同步信号SYN + B's Initial sequence number + B's ACK sequence number

A与B就A的初始序列号达成了一致（A可以向B成功发送数据），这里是1000(举例)。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。(B能否向A成功发送数据就无法保证) **如果B没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。**

####(3)为什么需要四次挥手

保证释放连接的可靠性。