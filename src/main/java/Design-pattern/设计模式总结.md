# 设计模式总结

## 一、设计原则

1.开闭原则

对扩展开放，对修改关闭。面向抽象编程。

2.依赖倒置原则

高层模块不应该依赖底层模块，两者都应该依赖其抽象。面向接口编程。

3.单一职责原则

一个类/接口/方法只有一种引起它变更的原因，要求接口、方法做到单一职责原则。

4.接口隔离原则

接口拆分要适度。

5.迪米特法则(最少知道原则)

一个对象应该对其他对象保持最少的了解，尽量降低类与类之间的耦合性。

6.里式替换原则

所有引用基类（父类）的地方必须能透明地使用其子类的对象。

7.合成/复用原则(组合/复用原则)

尽量使用**对象组合**，而不是**继承**来达到复用的目的。

## 二、创建型

### 1.简单工厂模式

简单工厂模式通常是一个工厂类 `XxxFactory`，里面有一个(静态)方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。

#### (1)实例

```java
public abstract class Video {
    public abstract void produce();
}
public class JavaVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Java课程视频");
    }
}
public class PythonVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Python课程视频");
    }
}

// 简单工厂
public class VideoFactory {
    // 使用反射，便与扩展
    public Video getVideo(Class<? extends Video> clazz) {
        Video video = null;
        try {
            video = (Video) Class.forName(clazz.getName()).newInstance();
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return video;
    }

    public Video getVideo(String type) {
        if ("java".equalsIgnoreCase(type)) {
            return new JavaVideo();
        } else if ("python".equalsIgnoreCase(type)) {
            return new PythonVideo();
        } else {
            return null;
        }
    }
}

// 测试
public class Test {
    public static void main(String[] args) {
//        VideoFactory videoFactory = new VideoFactory();
//        Video video = videoFactory.getVideo("java");
//        video.produce();

        VideoFactory videoFactory = new VideoFactory();
        Video video = videoFactory.getVideo(PythonVideo.class);
        if (video == null) {
            return;
        }
        video.produce();
    }
}
```

#### (2)应用

`java.util.Calendar.createCalendar`方法中的简单工厂应用:

```java
// 代码片段
Calendar cal = null;

if (aLocale.hasExtensions()) {
    String caltype = aLocale.getUnicodeLocaleType("ca");
    if (caltype != null) {
        switch (caltype) {
        case "buddhist":
        cal = new BuddhistCalendar(zone, aLocale);
            break;
        case "japanese":
            cal = new JapaneseImperialCalendar(zone, aLocale);
            break;
        case "gregory":
            cal = new GregorianCalendar(zone, aLocale);
            break;
        }
    }
}
if (cal == null) {
    if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
        cal = new BuddhistCalendar(zone, aLocale);
    } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
               && aLocale.getCountry() == "JP") {
        cal = new JapaneseImperialCalendar(zone, aLocale);
    } else {
        cal = new GregorianCalendar(zone, aLocale);
    }
}
return cal;
```

### 2.工厂方法模式

定义一个创建对象的接口，但让实现这个接口的类决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。适用于同一产品等级。

#### (1)实例

```java
public abstract class Video {
    public abstract void produce();
}
// 创建对象的接口
public abstract class VideoFactory {
    public abstract Video geVideo();
}

public class FEVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制FE课程视频");
    }
}
public class FEVideoFactory extends VideoFactory {
    @Override
    public Video geVideo() {
        return new FEVideo();
    }
}
public class JavaVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Java课程视频");
    }
}
public class JavaVideoFactory extends VideoFactory {
    @Override
    public Video geVideo() {
        return new JavaVideo();
    }
}
// 测试
// 同一产品等级，使用工厂方法
public class Test {
    public static void main(String[] args) {
        VideoFactory videoFactory = new JavaVideoFactory();
        VideoFactory videoFactory2 = new FEVideoFactory();
        Video video = videoFactory.geVideo();
        video.produce();
    }
}
```

#### (2)应用

slf4j与logback:

工厂方法：org.slf4j.ILoggerFactory.getLogger

```java
// slf4j
public interface ILoggerFactory {
    public Logger getLogger(String name);
}
```

工厂实现：ch.qos.logback.classic.LoggerContext

```java
// logback
public final Logger getLogger(final String name) {

    //...
    if (Logger.ROOT_LOGGER_NAME.equalsIgnoreCase(name)) {
        return root;
    }

    int i = 0;
    Logger logger = root;

    Logger childLogger = (Logger) loggerCache.get(name);
    if (childLogger != null) {
        return childLogger;
    }

    String childName;
    while (true) {
        int h = LoggerNameUtil.getSeparatorIndexOf(name, i);
        if (h == -1) {
            childName = name;
        } else {
            childName = name.substring(0, h);
        }
        i = h + 1;
        synchronized (logger) {
            childLogger = logger.getChildByName(childName);
            if (childLogger == null) {
                childLogger = logger.createChildByName(childName);
                loggerCache.put(childName, childLogger);
                incSize();
            }
        }
        logger = childLogger;
        if (h == -1) {
            return childLogger;
        }
    }
}
```

抽象产品：**org.slf4j.Logger**

具体产品：**ch.qos.logback.classic.Logger**

### 3.抽象工厂模式

抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口。(产品族)

#### (1)实例

```java
// 抽象工厂
public interface CourseFactory {
    Video getVideo(); // 获取视频
    Article getArticle(); // 获取手记
}
public abstract class Video {
    public abstract void produce();
}
public abstract class Article {
    public abstract void produce();
}
public class JavaVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Java课程视频");
    }
}
public class JavaArticle extends Article {
    @Override
    public void produce() {
        System.out.println("录制Java课程手记");
    }
}
public class JavaCourseFactory implements CourseFactory {
    @Override
    public Video getVideo() {
        return new JavaVideo();
    }

    @Override
    public Article getArticle() {
        return new JavaArticle();
    }
}
public class PythonVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Python课程视频");
    }
}
public class PythonArticle extends Article {
    @Override
    public void produce() {
        System.out.println("录制Python课程手记");
    }
}
public class PythonCourseFactory implements CourseFactory {
    @Override
    public Video getVideo() {
        return new PythonVideo();
    }

    @Override
    public Article getArticle() {
        return new PythonArticle();
    }
}
// 同一产品簇，使用抽象工厂
public class Test {
    public static void main(String[] args) {
        CourseFactory courseFactory = new JavaCourseFactory();
        Video video = courseFactory.getVideo();
        Article article = courseFactory.getArticle();
        video.produce();
        article.produce();
    }
}
```

#### (2)应用

org.apache.ibatis.session.SqlSessionFactory:

```java
public interface SqlSessionFactory {

  SqlSession openSession(); // 获取SqlSession

  SqlSession openSession(boolean autoCommit);
  SqlSession openSession(Connection connection);
  SqlSession openSession(TransactionIsolationLevel level);

  SqlSession openSession(ExecutorType execType);
  SqlSession openSession(ExecutorType execType, boolean autoCommit);
  SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);
  SqlSession openSession(ExecutorType execType, Connection connection);

  Configuration getConfiguration(); // 获取配置

}
```

### 4.建造者模式