# 设计模式总结

## 一、设计原则

1.开闭原则

对扩展开放，对修改关闭。面向抽象编程。

2.依赖倒置原则

高层模块不应该依赖底层模块，两者都应该依赖其抽象。面向接口编程。

3.单一职责原则

一个类/接口/方法只有一种引起它变更的原因，要求接口、方法做到单一职责原则。

4.接口隔离原则

接口拆分要适度。

5.迪米特法则(最少知道原则)

一个对象应该对其他对象保持最少的了解，尽量降低类与类之间的耦合性。

6.里式替换原则

所有引用基类（父类）的地方必须能透明地使用其子类的对象。

7.合成/复用原则(组合/复用原则)

尽量使用**对象组合**，而不是**继承**来达到复用的目的。

## 二、创建型

### 1.简单工厂模式

简单工厂模式通常是一个工厂类 `XxxFactory`，里面有一个(静态)方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。

#### (1)实例

```java
public abstract class Video {
    public abstract void produce();
}
public class JavaVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Java课程视频");
    }
}
public class PythonVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Python课程视频");
    }
}

// 简单工厂
public class VideoFactory {
    // 使用反射，便与扩展
    public Video getVideo(Class<? extends Video> clazz) {
        Video video = null;
        try {
            video = (Video) Class.forName(clazz.getName()).newInstance();
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return video;
    }

    public Video getVideo(String type) {
        if ("java".equalsIgnoreCase(type)) {
            return new JavaVideo();
        } else if ("python".equalsIgnoreCase(type)) {
            return new PythonVideo();
        } else {
            return null;
        }
    }
}

// 测试
public class Test {
    public static void main(String[] args) {
//        VideoFactory videoFactory = new VideoFactory();
//        Video video = videoFactory.getVideo("java");
//        video.produce();

        VideoFactory videoFactory = new VideoFactory();
        Video video = videoFactory.getVideo(PythonVideo.class);
        if (video == null) {
            return;
        }
        video.produce();
    }
}
```

#### (2)应用

`java.util.Calendar.createCalendar`方法中的简单工厂应用:

```java
// 代码片段
Calendar cal = null;

if (aLocale.hasExtensions()) {
    String caltype = aLocale.getUnicodeLocaleType("ca");
    if (caltype != null) {
        switch (caltype) {
        case "buddhist":
        cal = new BuddhistCalendar(zone, aLocale);
            break;
        case "japanese":
            cal = new JapaneseImperialCalendar(zone, aLocale);
            break;
        case "gregory":
            cal = new GregorianCalendar(zone, aLocale);
            break;
        }
    }
}
if (cal == null) {
    if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
        cal = new BuddhistCalendar(zone, aLocale);
    } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
               && aLocale.getCountry() == "JP") {
        cal = new JapaneseImperialCalendar(zone, aLocale);
    } else {
        cal = new GregorianCalendar(zone, aLocale);
    }
}
return cal;
```

### 2.工厂方法模式

定义一个创建对象的接口，但让实现这个接口的类决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。适用于同一产品等级。

#### (1)实例

```java
public abstract class Video {
    public abstract void produce();
}
// 创建对象的接口
public abstract class VideoFactory {
    public abstract Video geVideo();
}

public class FEVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制FE课程视频");
    }
}
public class FEVideoFactory extends VideoFactory {
    @Override
    public Video geVideo() {
        return new FEVideo();
    }
}
public class JavaVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Java课程视频");
    }
}
public class JavaVideoFactory extends VideoFactory {
    @Override
    public Video geVideo() {
        return new JavaVideo();
    }
}
// 测试
// 同一产品等级，使用工厂方法
public class Test {
    public static void main(String[] args) {
        VideoFactory videoFactory = new JavaVideoFactory();
        VideoFactory videoFactory2 = new FEVideoFactory();
        Video video = videoFactory.geVideo();
        video.produce();
    }
}
```

#### (2)应用

slf4j与logback:

工厂方法：org.slf4j.ILoggerFactory.getLogger

```java
// slf4j
public interface ILoggerFactory {
    public Logger getLogger(String name);
}
```

工厂实现：ch.qos.logback.classic.LoggerContext

```java
// logback
public final Logger getLogger(final String name) {

    //...
    if (Logger.ROOT_LOGGER_NAME.equalsIgnoreCase(name)) {
        return root;
    }

    int i = 0;
    Logger logger = root;

    Logger childLogger = (Logger) loggerCache.get(name);
    if (childLogger != null) {
        return childLogger;
    }

    String childName;
    while (true) {
        int h = LoggerNameUtil.getSeparatorIndexOf(name, i);
        if (h == -1) {
            childName = name;
        } else {
            childName = name.substring(0, h);
        }
        i = h + 1;
        synchronized (logger) {
            childLogger = logger.getChildByName(childName);
            if (childLogger == null) {
                childLogger = logger.createChildByName(childName);
                loggerCache.put(childName, childLogger);
                incSize();
            }
        }
        logger = childLogger;
        if (h == -1) {
            return childLogger;
        }
    }
}
```

抽象产品：**org.slf4j.Logger**

具体产品：**ch.qos.logback.classic.Logger**

### 3.抽象工厂模式

抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口。(产品族)

#### (1)实例

```java
// 抽象工厂
public interface CourseFactory {
    Video getVideo(); // 获取视频
    Article getArticle(); // 获取手记
}
public abstract class Video {
    public abstract void produce();
}
public abstract class Article {
    public abstract void produce();
}
public class JavaVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Java课程视频");
    }
}
public class JavaArticle extends Article {
    @Override
    public void produce() {
        System.out.println("录制Java课程手记");
    }
}
public class JavaCourseFactory implements CourseFactory {
    @Override
    public Video getVideo() {
        return new JavaVideo();
    }

    @Override
    public Article getArticle() {
        return new JavaArticle();
    }
}
public class PythonVideo extends Video {
    @Override
    public void produce() {
        System.out.println("录制Python课程视频");
    }
}
public class PythonArticle extends Article {
    @Override
    public void produce() {
        System.out.println("录制Python课程手记");
    }
}
public class PythonCourseFactory implements CourseFactory {
    @Override
    public Video getVideo() {
        return new PythonVideo();
    }

    @Override
    public Article getArticle() {
        return new PythonArticle();
    }
}
// 同一产品簇，使用抽象工厂
public class Test {
    public static void main(String[] args) {
        CourseFactory courseFactory = new JavaCourseFactory();
        Video video = courseFactory.getVideo();
        Article article = courseFactory.getArticle();
        video.produce();
        article.produce();
    }
}
```

#### (2)应用

org.apache.ibatis.session.SqlSessionFactory:

```java
public interface SqlSessionFactory {

  SqlSession openSession(); // 获取SqlSession

  SqlSession openSession(boolean autoCommit);
  SqlSession openSession(Connection connection);
  SqlSession openSession(TransactionIsolationLevel level);

  SqlSession openSession(ExecutorType execType);
  SqlSession openSession(ExecutorType execType, boolean autoCommit);
  SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);
  SqlSession openSession(ExecutorType execType, Connection connection);

  Configuration getConfiguration(); // 获取配置

}
```

### 4.建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需指定需要创建的类型就可以得到它们，建造过程和细节不需要知道。

#### (1)实例

```java
import lombok.Builder;

// 建造者设计模式
//@Builder
public class User {
    private String name;
    private String password;
    private String nickname;
    private int age;

    private User(String name, String password, String nickname, int age) {
        this.name = name;
        this.password = password;
        this.nickname = nickname;
        this.age = age;
    }
		// Builder
    public static UserBuilder builder() {
        return new UserBuilder();
    }

    public static class UserBuilder {
        private String name;
        private String password;
        private String nickname;
        private int age;

        private UserBuilder() {
        }

        public UserBuilder name(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder password(String password) {
            this.password = password;
            return this;
        }

        public UserBuilder nickname(String nickname) {
            this.nickname = nickname;
            return this;
        }

        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }

        public User build() {
            if (name == null || password == null) {
                throw new RuntimeException("用户名和密码必填");
            }
            if (age <= 0 || age >= 150) {
                throw new RuntimeException("年龄不合法");
            }
            // 还可以做赋予”默认值“的功能
            if (nickname == null) {
                nickname = name;
            }
            return new User(name, password, nickname, age);
        }
    }

}

public class Test {
    public static void main(String[] args){
        User u = User.builder()
                .name("foo")
                .age(25)
                .password("pass12345")
                .build();

    }
}
```

#### (2)应用

- JDK:
  - StringBuilder
  - StringBuffer

- Guava:
  - ImmutableSet
  - CacheBuilder 

### 5.单例模式

#### (1)懒汉式1

```java
// 同步锁synchronized
public class LazySingleton {
    private static LazySingleton instance = null;

    private LazySingleton() {
        // 无法阻止反射攻击
        if (instance != null) {
            throw new RuntimeException("单例构造器禁用反射调用");
        }
    }

    public synchronized static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

#### (2)懒汉式2

```java
// 双重检查+volatile
public class LazyDoubleCheckSingleton {
    private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null;

    private LazyDoubleCheckSingleton() {

    }

    public static LazyDoubleCheckSingleton getInstance() {
        if (lazyDoubleCheckSingleton == null) {
            synchronized (LazyDoubleCheckSingleton.class) {
                if (lazyDoubleCheckSingleton == null) {
                    lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton();
                    //1.分配内存给这个对象
//                  //3.设置lazyDoubleCheckSingleton 指向刚分配的内存地址
                    //2.初始化对象
//                    intra-thread semantics
//                    ---------------//3.设置lazyDoubleCheckSingleton 指向刚分配的内存地址
                }
            }
        }
        return lazyDoubleCheckSingleton;
    }
}
```

#### (3)静态嵌套类

```java
// 静态嵌套类单例
public class StaticNestedClassSingleton {

    // 静态嵌套类可以访问外围类的静态属性和方法
    private static class StaticNestedClass {
        private static StaticNestedClassSingleton staticNestedClassSingleton = new StaticNestedClassSingleton();
    }

    public static StaticNestedClassSingleton getInstance() {
        return StaticNestedClass.staticNestedClassSingleton; // 初始化
    }

    private StaticNestedClassSingleton() {
        // 防止反射攻击
        if (StaticNestedClass.staticNestedClassSingleton != null) {
            throw new RuntimeException("单例构造器禁用反射调用");
        }
    }

}
```

#### (4)饿汉式

```java
// 饿汉式单例
public class HungrySingleton implements Serializable, Cloneable {
    private static final HungrySingleton instance;

    static {
        instance = new HungrySingleton();
    }

    public static HungrySingleton getInstance() {
        return instance;
    }

    private HungrySingleton() {
        // 防止反射攻击
        if (instance != null) {
            throw new RuntimeException("单例构造器禁用反射调用");
        }
    }

    // 防止序列化与反序列化破坏单例模式
    private Object readResolve() {
        return instance;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
//        return super.clone();
        return getInstance();
    }
}
```

#### (5)容器单例

```java
// 容器单例，非线程安全。适合在类初始化的时候使用，维护很多单例
public class ContainerSingleton {

    private ContainerSingleton() {

    }

    private static Map<String, Object> singletonMap = new HashMap<>();

    public static void putInstance(String key, Object instance) {
        if (StringUtils.isNotBlank(key) && instance != null) {
            if (!singletonMap.containsKey(key)) {
                singletonMap.put(key, instance);
            }
        }
    }

    public static Object getInstance(String key) {
        return singletonMap.get(key);
    }

}
```

#### (6)枚举单例

```java
// 枚举单例
public enum EnumSingleton {
    INSTANCE{
        @Override
        protected void printTest() {
            System.out.println("print test jat,,,");
        }
    };

    protected abstract void printTest();

    private Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static EnumSingleton getInstance() {
        return INSTANCE;
    }

}
```

#### (7)ThreadLocalSingleton

```java
// 线程内单例
public class ThreadLocalSingleton {
    private static final ThreadLocal<ThreadLocalSingleton> THREAD_LOCAL_SINGLETON_THREAD_LOCAL
            = new ThreadLocal<ThreadLocalSingleton>() {
        @Override
        protected ThreadLocalSingleton initialValue() {
            return new ThreadLocalSingleton();
        }
    };

    private ThreadLocalSingleton() {

    }

    public static ThreadLocalSingleton getInstance() {
        return THREAD_LOCAL_SINGLETON_THREAD_LOCAL.get();
    }

}
```

#### (8)应用

`java.lang.Runtime.getRuntime` 饿汉式

```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();
 
  	private Runtime() {}
  
    public static Runtime getRuntime() {
        return currentRuntime;
    }
}
```

### 6.原型模式

原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

#### (1)实例

```java
// 抽象类
public abstract class A implements Cloneable {
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

// 实现类
public class B extends A {
    public static void main(String[] args) throws CloneNotSupportedException {
        B b = new B();
        B b2 = (B) b.clone();
        System.out.println(b);
        System.out.println(b2);
    }
}
```

```java
// 深拷贝与浅拷贝
public class Pig implements Cloneable {
    private String name;
    private Date birthday;

    public Pig(String name, Date birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    @Override
    public String toString() {
        return "Pig{" +
                "name='" + name + '\'' +
                ", birthday=" + birthday +
                '}' + "--" + super.toString();
    }

    // 浅拷贝
//    @Override
//    protected Object clone() throws CloneNotSupportedException {
//        return super.clone();
//    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        // 深拷贝
        Pig pig = (Pig) super.clone();
        pig.birthday = (Date) pig.birthday.clone();
        return pig;
    }
}
```

#### (2)应用

`ArrayList`:

```java
public Object clone() {
    try {
        ArrayList<?> v = (ArrayList<?>) super.clone();
        v.elementData = Arrays.copyOf(elementData, size); // 元素引用相同
        v.modCount = 0;
        return v;
    } catch (CloneNotSupportedException e) {
        // this shouldn't happen, since we are Cloneable
        throw new InternalError(e);
    }
}
```

## 三、结构型

### 1.外观模式

又叫门面模式，提供了一个统一的接口(外观类)，用来访问子系统的一群接口。包含外观类、子系统、客户端三部分。

#### (1)实例

```java
// 积分兑换的礼物
public class PointGift {
    private String name;

    public PointGift(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

// 校验子系统
public class QualifyService {
    public boolean isAvailable(PointGift pointGift) {
        System.out.println("校验 " + pointGift.getName() + " 积分资格通过, 库存通过");
        return true;
    }
}

// 扣减积分子系统
public class PointPaymentService {
    public boolean pay(PointGift pointGift) {
        // 扣减积分
        System.out.println("支付 " + pointGift.getName() + " 积分成功");
        return true;
    }
}

// 物流子系统
public class ShippingService {
    public String shipGift(PointGift pointGift) {
        // 物流系统的对接逻辑
        System.out.println(pointGift.getName() + " 进入物流系统");
        String shippingOrderNo = "666";
        return shippingOrderNo;
    }
}

// 外观类
public class GiftExchangeService {
    private QualifyService qualifyService = new QualifyService();
    private PointPaymentService pointPaymentService = new PointPaymentService();
    private ShippingService shippingService = new ShippingService();

    public void giftExchange(PointGift pointGift) {
        if (qualifyService.isAvailable(pointGift)) {
            // 资格校验通过
            if (pointPaymentService.pay(pointGift)) {
                // 积分支付通过
                String shippingOrderNo = shippingService.shipGift(pointGift);
                System.out.println("物流系统下单成功,订单号是: " + shippingOrderNo);
            }
        }
    }

}

// 客户端
public class Test {
    public static void main(String[] args) {

        PointGift pointGift = new PointGift("T恤");
        // 外观对象
        GiftExchangeService giftExchangeService = new GiftExchangeService();

        giftExchangeService.giftExchange(pointGift);

    }
}
```

#### (2)应用

`org.springframework.jdbc.support.JdbcUtils`:

```java
public static void closeConnection(Connection con) {
   if (con != null) {
      try {
         con.close();
      }
      catch (SQLException ex) {
         logger.debug("Could not close JDBC Connection", ex);
      }
      catch (Throwable ex) {
         // We don't trust the JDBC driver: It might throw RuntimeException or Error.
         logger.debug("Unexpected exception on closing JDBC Connection", ex);
      }
   }
}
```

### 2.装饰者模式

在不改变原有对象的基础上，将功能附加到对象之上。提供了比继承更具弹性的替代方案。(扩展了原有对象的功能)

#### (1)实例

```java
// 抽象被装饰者
public abstract class ABattercake {
    protected abstract String getDesc();
    protected abstract int cost();
}

// 具体被装饰者
public class Battercake extends ABattercake {
    @Override
    protected String getDesc() {
        return "煎饼";
    }

    @Override
    protected int cost() {
        return 8;
    }
}

// 抽象装饰者
public abstract class AbstractDecorator extends ABattercake {

    private ABattercake aBattercake;

    public AbstractDecorator(ABattercake aBattercake) {
        this.aBattercake = aBattercake;
    }

    protected abstract void doSomething();

    @Override
    protected String getDesc() {
        return this.aBattercake.getDesc();
    }

    @Override
    protected int cost() {
        return this.aBattercake.cost();
    }
}

// 具体装饰者1
public class EggDecorator extends AbstractDecorator {
    public EggDecorator(ABattercake aBattercake) {
        super(aBattercake);
    }

    @Override
    protected void doSomething() {

    }

    @Override
    protected String getDesc() {
        return super.getDesc() + ", 加鸡蛋";
    }

    @Override
    protected int cost() {
        return super.cost() + 1;
    }
}

// 具体装饰者2
public class SausageDecorator extends AbstractDecorator {
    public SausageDecorator(ABattercake aBattercake) {
        super(aBattercake);
    }

    @Override
    protected void doSomething() {

    }

    @Override
    protected String getDesc() {
        return super.getDesc() + ", 加香肠";
    }

    @Override
    protected int cost() {
        return super.cost() + 2;
    }
}

// 测试
public class Test {
    public static void main(String[] args) {
        ABattercake aBattercake = new Battercake(); 
        aBattercake = new EggDecorator(aBattercake); // 加鸡蛋
        aBattercake = new EggDecorator(aBattercake); // 加鸡蛋
        aBattercake = new SausageDecorator(aBattercake); // 再加香肠
        System.out.println(aBattercake.getDesc() + " 销售价格: " + aBattercake.cost());
    }
}
```

UML图：

![](https://alvin-jay.oss-cn-hangzhou.aliyuncs.com/design-pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8Fuml.jpg?x-oss-process=style/markdown-pic)

#### (2)应用

Java IO中的装饰者模式应用：

![](https://alvin-jay.oss-cn-hangzhou.aliyuncs.com/design-pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B9%8BIO%E6%B5%81.jpg)

```java
DataInputStream is = new DataInputStream(
                              new BufferedInputStream(
                                  new FileInputStream("demo.txt")));
```

